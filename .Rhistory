head(d)
d$society
d$logpop
d$total_tools
m10.10 <- map(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + bp * log_pop +
bc * contact_high + bpc*contact_high*log_pop,
a ~ dnorm(0, 100),
c(bp, bc, bpc) ~ dnorm(0, 1)
),
data = d)
d$log_pop <- log(d$population)
d$contact_high <- ifelse(d$contact=="high", 1, 0)
m10.10 <- map(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + bp * log_pop +
bc * contact_high + bpc*contact_high*log_pop,
a ~ dnorm(0, 100),
c(bp, bc, bpc) ~ dnorm(0, 1)
),
data = d)
precis(m10.10, corr = T)
plot(precis(m10.10))
post <- extract.samples(m13.7)
curve(median(post$etasq) * exp(-median(post$rhosq)*x^2), from = 0, to = 10)
curve(median(post$etasq) * exp(-median(post$rhosq)*x^2), from = 0, to = 10,
xlab = "distance (thousand km)", ylab = "covariance", ylim=c(0,1),
yaxp=c(0,1,4), lwd=2)
for(i in 1:100)
curve(post$etasq[i]*exp(-post$rhosq[i]*x^2), add = T,
col=col.alpha("black", 0.2))
K <- matrix(0, nrow = 10, ncol = 10)
K <- matrix(0, nrow = 10, ncol = 10)
for (i in 1:10)
for (j in 1:10)
k[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2)
diag(K) <- median(post$etasq) + 0.01
K <- matrix(0, nrow = 10, ncol = 10)
for (i in 1:10)
for (j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2)
diag(K) <- median(post$etasq) + 0.01
K
K <- matrix(0, nrow = 10, ncol = 10)
K
for (i in 1:10)
for (j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2)
diag(K) <- median(post$etasq) + 0.01
K
K <- matrix(0, nrow = 10, ncol = 10)
K
for (i in 1:10)
for (j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2)
diag(K) <- median(post$etasq) + 0.01
K <- matrix(0, nrow = 10, ncol = 10)
K
for (i in 1:10)
for (j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2)
K
diag(K) <- median(post$etasq) + 0.01
K
Rho <- round(cov2cor(K), 2)
colnames(Rho) <- c("Ml", "Ti", "SC", "Ya", "Fi", "Tr", "Ch", "Mn", "To", "Ha")
rownames(Rho) <- colnames(Rho)
Rho
psize <- d$log_pop / max(d$log_pop)
psize <- exp(psize*1.5)-2
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col.alpha("black", Rho[i,j]^2))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col.alpha("black", Rho[i,j]^2))
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col.alpha("black", Rho[i,j]^2))
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
logpop <-seq(6, 14, length.out = 30)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
# display posterior predictions
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
# overlay correlations
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
logpop <-seq(6, 14, length.out = 30)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lambda.median <- apply(lambda, 2, median)
lamda.PI80 <- apply(lambda, 2, PI, prob=0.8)
# plot raw data and labels
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
# display posterior predictions
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
# overlay correlations
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
# overlay lines shaded by Rho
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
logpop <-seq(6, 14, length.out = 30)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lambda.median <- apply(lambda, 2, median)
lamda.PI80 <- apply(lambda, 2, PI, prob=0.8)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
logpop <-seq(6, 14, length.out = 30)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lines(logpop.seq, lambda.median, lty=2)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lambda.median <- apply(lambda, 2, median)
lamda.PI80 <- apply(lambda, 2, PI, prob=0.8)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
m10.12 <- map(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + bp*log_pop,
a ~ dnorm(0, 100),
bp ~ dnorm(0, 1)
), data = d)
compare(m10.12, m13.7)
WAIC(m10.12, m13.7)
WAIC(m10.12)
WAIC(m13.7)
precis(m10.12)
precis(m10.12, depth = 2)
precis(m13.7, depth = 2)
m10 <- map(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + bp * logpop,
a ~ dnorm(0, 10),
c(bp) ~ dnorm(0, 1)
),
data = d)
m <- map2stan(
alist(
total_tools ~ dpois(lambda),
log(lambda) <- a + bp*logpop,
a ~ dnorm(0, 10),
bp ~ dnorm(0, 1)
),
data = d, warmup = 2000, iter = 4000, chains = 4
)
compare(m10.12, m13.7)
precis(m, depth = 2)
precis(m13.7, depth = 2)
precis(m, depth = 2)
WAIC(m, m13.7)
WAIC(m)
WAIC(m13.7)
Dmat <- islandsDistMatrix
Dmat
?curve: # Draws a curve corresponding to a function over the interval [from, to].
exp(-4)
?curve: # Draws a curve corresponding to a function over the interval [from, to].
exp(-4)
?curve # Draws a curve corresponding to a function over the interval [from, to].
?exp
exp(0)
exp(-4)
precis(m, corr = T)
K <- matrix(0, nrow = 10, ncol = 10)
K
for (i in 1:10)
for (j in 1:10)
K[i,j] <- median(post$etasq) *
exp(-median(post$rhosq) * islandsDistMatrix[i,j]^2) # why all multiply???
K
diag(K) <- median(post$etasq) + 0.01 # adding the constant extra coviance beyound eta when i=j
K
Rho <- round(cov2cor(K), 2) # two digit numbers
Rho
psize <- d$log_pop / max(d$log_pop)
psize <- exp(psize*1.5)-2
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
text(d$lon2, d$lat, labels = labels, cex = 0.7)
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
psize <- d$log_pop / max(d$log_pop)
psize <- exp(psize*1.5)-2
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7)
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2))
?text
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
d$lon2
length(d$lon2)
?lines
for (i in 1:10)
for (j in 1:10)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
?lines
for (i in 1:10)
for (j in 1:10)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2)) # pos tell it not to overlay
for (i in 1:10)
for (j in 1:10)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2)) # pos tell it not to overlay
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
lines(c(1,2), c(2,3), lwd=2, col=col.alpha("black"))
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2)) # pos tell it not to overlay
lines(c(1,2), c(2,3), lwd=2, col=col.alpha("black"))
?lines
logpop.seq <-seq(6, 14, length.out = 30)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lambda.median <- apply(lambda, 2, median)
lamda.PI80 <- apply(lambda, 2, PI, prob=0.8)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
for (i in 1:10)
logpop.seq <-seq(6, 14, length.out = 30)
lambda <- sapply(logpop.seq, function(lp) exp(post$a + post$bp*lp))
lambda.median <- apply(lambda, 2, median)
lambda.PI80 <- apply(lambda, 2, PI, prob=0.8)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lamdda.PI80[2,],lty=2)
lines(logpop.seq, lambda.PI80[2,],lty=2)
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
?plot
psize
plot(d$lon2, d$lat, xlab="longitude", ylab="latitute",
col=rangi2, cex=psize, pch=16, xlim=c(-50, 30))
?plot # cex: point size
labels <- as.character(d$culture)
text(d$lon2, d$lat, labels = labels, cex = 0.7, pos = c(2,4,3,3,4,1,3,2,4,2)) # pos tell it not to overlay
for (i in 1:10)
for (j in 1:10)
if (i < j) # only to compute once
lines(c(d$lon2[i],d$lon2[j]), c(d$lat[i], d$lat[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
Rho
post$a
lambda
dim(lambda)
lambda.median <- apply(lambda, 2, median)
lambda.median
lambda.PI80 <- apply(lambda, 2, PI, prob=0.8)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lambda.PI80[2,],lty=2)
plot(d$logpop, d$total_tools, col=rangi2, cex=psize, pch=16,
xlab="log population", ylab="total tools")
text(d$logpop, d$total_tools, labels = labels, cex = 0.7,
pos=c(4,3,4,2,2,1,4,4,4,2))
lines(logpop.seq, lambda.median, lty=2)
lines(logpop.seq, lambda.PI80[1,],lty=2)
lines(logpop.seq, lambda.PI80[2,],lty=2)
for (i in 1:10)
for (j in 1:10)
if (i < j)
lines(c(d$logpop[i], d$logpop[j]),
c(d$total_tools[i], d$total_tools[j]),
lwd=2, col=col.alpha("black", Rho[i,j]^2))
WAIC(m)
WAIC(m13.7)
WAIC(m13.6NC)
library(rethinking)
data("chimpanzees")
d <- chimpanzees
d$recipient <- NULL
d$block_id <- d$block
head(d)
m13.6 <- map2stan(
alist(
# likelihood
pulled_left ~ dbinom(1, p), # likelihood
# linear model
logit(p) <- A + (BP + BPC*condition)*prosoc_left, # linear model
A <- a + a_actor[actor] + a_block[block_id],
BP <- bp + bp_actor[actor] + bp_block[block_id],
BPC <- bpc + bpc_actor[actor] + bpc_block[block_id],
# adaptive priors
c(a_actor, bp_actor, bpc_actor)[actor] ~
dmvnorm2(0, sigma_actor, Rho_actor), # covariant matrix
c(a_block, bp_block, bpc_block)[block_id] ~
dmvnorm2(0, sigma_block, Rho_block),
# fixed priors
c(a,bp,bpc) ~ dnorm(0, 1),
sigma_actor ~ dcauchy(0, 2),
sigma_block ~ dcauchy(0, 2),
Rho_actor ~ dlkjcorr(4),
Rho_block ~ dlkjcorr(4)
), data = d, iter = 5000, warmup = 1000, chains = 3, cores = 3)
# R code 12.23
m13.6NC <- map2stan(
alist(
# likelihood
pulled_left ~ dbinom(1, p), # likelihood
# linear model
logit(p) <- A + (BP + BPC*condition)*prosoc_left, # linear model
A <- a + a_actor[actor] + a_block[block_id],
BP <- bp + bp_actor[actor] + bp_block[block_id],
BPC <- bpc + bpc_actor[actor] + bpc_block[block_id],
# adaptive priors
c(a_actor, bp_actor, bpc_actor)[actor] ~
dmvnormNC(sigma_actor, Rho_actor), # covariant matrix, no 0 here compared the last map2stan model
c(a_block, bp_block, bpc_block)[block_id] ~
dmvnormNC(sigma_block, Rho_block),
# fixed priors
c(a,bp,bpc) ~ dnorm(0, 1),
sigma_actor ~ dcauchy(0, 2),
sigma_block ~ dcauchy(0, 2),
Rho_actor ~ dlkjcorr(4),
Rho_block ~ dlkjcorr(4)
), data = d, iter = 5000, warmup = 1000, chains = 3, cores = 3)
precis(m13.6, depth = 2)
precis(m13.6NC, depth = 2)
# R code 13.24
# extract n_eff values for each model
neff_c <- precis(m13.6, 2)@output$n_eff # don't understand this code, discuss with Julin
neff_nc <- precis(m13.6NC,2)@output$n_eff
# plot distributions
boxplot(list('m13.6'=neff_c, 'm13.6NC'=neff_nc),
ylab="effective samples", xlab="model")
WAIC(m13.6NC)
WAIC(m13.6)
WAIC(m)
WAIC(m13.7)
WAIC(m)
WAIC(m13.7) # more???
head(d2)
data("Oxboys")
d2 <- Oxboys
head(d2)
d2$Subject
head(d2)
d2$Occasion
234/26
d2$height
mean(d2$height)
st(d2$height)
sd(d2$height)
Dmat
d2$Subject
d2$age
head(d2)
head(Kline2)
Kline2
head(Kline2)
Kline2
WAIC(m)
WAIC(m13.7) # more parameters due to the extra cosideration of society ...
data("Oxboys")
d2 <- Oxboys
head(d2)
head(d2, 20)
head(d2)
d2$Subject
head(d2)
d2$age
d2$Subject
d2$Subject==1
d2[d2$Subject==1]
d2[d2$Subject==1,]
d2[d2$Subject==1,]$age
mean(d2[d2$Subject==1,]$age)
mean(d2[d2$Subject==2,]$age)
mean(d2[d2$Subject==3,]$age)
?distance
dist(d2)
dist(d2)
mean(d2$height)
head(d2)
d2$Occasion
?dist
dist(d2$Subject)
dist(d2$age)
head(d2)
d2[d2$Subject==1,]
d2[d2$Subject==1,]$height
mean(d2[d2$Subject==1,]$height)
mean(d2[d2$Subject==2,]$height)
mean(d2[d2$Subject==3,]$height)
mean(d2[d2$Subject==3,]$age)
head(d2)
mean(d2[d2$Subject==4,]$age)
mean(d2[d2$Subject==2,]$age)
as.matrix(dist(d2))
Dmat2 <- as.matrix(dist(d2))
Dmat2
Kline2
Dmat
Dmat2 <- as.matrix(dist(d2))
Dmat2
?dist
