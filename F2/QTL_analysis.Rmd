---
title: "QTL_analysis"
author: "Ruijuan Li"
date: "9/26/2017"
output: 
  html_document: 
    keep_md: yes
---

Goal of this project: to map QTL using the genetic map that I constructed from F2 mapping population created from Da-Ae & Da-Ol-1 

```{r}
library(tidyverse)
library(qtl)
library(snowfall)
```

### reformat file with geno and pheno info
```{r}
# geno data 
F2_geno_data_2_Ae_Ol_new <- read.table("~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/F2_geno_data_2_Ae_Ol_new.txt")
dim(F2_geno_data_2_Ae_Ol_new) # 3443 166 
F2_geno_data_2_Ae_Ol_new[1:10, 1:10]

# pheno data 
pheno <- read.csv("~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/F2_Phenotype_Bnapus_all.csv", header = T, row.names = 1)
dim(pheno) # 42 166 
pheno[1:10, 1:10]
rownames(pheno) <- gsub("\ ", "_", rownames(pheno))
rownames(pheno) <- gsub("-", "_", rownames(pheno))
rownames(pheno) <- gsub("\\.", "_", rownames(pheno)) 

# combine geno & pheno data for QTL analysis 
colnames(F2_geno_data_2_Ae_Ol_new) <- gsub("X", "ID_", colnames(F2_geno_data_2_Ae_Ol_new))
F2_geno_data_2_Ae_Ol_new[1:10, 1:10]

F2_geno_data_2_Ae_Ol_new.t <- as.data.frame(t(F2_geno_data_2_Ae_Ol_new))
F2_geno_data_2_Ae_Ol_new.t$ID <- rownames(F2_geno_data_2_Ae_Ol_new.t)
pheno.t <- as.data.frame(t(pheno)) 
pheno.t$ID <- rownames(pheno.t)

F2_geno_data_2_Ae_Ol_new.2 <- 
F2_geno_data_2_Ae_Ol_new.t %>% 
  left_join(pheno.t) %>% 
  select(-ID)  

dim(F2_geno_data_2_Ae_Ol_new.2) # 166 3485 
F2_geno_data_2_Ae_Ol_new.2[1:10, 3440:3485] 
F2_geno_data_2_Ae_Ol_new.2 <- t(F2_geno_data_2_Ae_Ol_new.2)

write.table(F2_geno_data_2_Ae_Ol_new.2, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/F2_geno_data_2_Ae_Ol_new.2.txt")
# change file format in linux 
# cat F2_geno_data_2_Ae_Ol_new.2.txt | sed 's/"//g' | awk '{first = $1; $1 = ""; print $0}' > tmp
# tail -3485 tmp > tmp.1 

write.table(rownames(F2_geno_data_2_Ae_Ol_new.2), file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/marker_info.txt" )
# cat marker_info.txt | awk '{print "*"$2}' | tail -3485 | sed 's/"//g' > marker_info_reform.txt

# paste marker_info_reform.txt tmp.1  | tr "\t" "\ " > F2_geno_for_one_map.txt
# cat ../../header_one_map_input F2_geno_for_one_map.txt > F2_geno_for_one_map_final.txt 
# change header info: maker number to the right marker number 
```

### load data 
```{r} 
LG.f2 <- read.cross("mm", file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/F2_geno_for_one_map_final.txt", mapfile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/LG.f2.madmapper.map")
```

### re-estimate map
```{r}
LG.f2

LG.f2.before.crossover <- LG.f2

for (chr in names(LG.f2$geno)) { # for each chromosome in cross genotype data
  my.chr <- get(chr,LG.f2$geno) # return the genotype data, including data & map
  print(paste(chr,"NA before",sum(is.na(my.chr$data)))) 
  if(ncol(my.chr$data) > 3) { 
    my.chr$data[,2:(ncol(my.chr$data)-1)] <- sapply(2:(ncol(my.chr$data)-1),function(i) {
      apply(my.chr$data[,(i-1):(i+1)],1,function(gt) {
        if (any(is.na(gt))) return(gt[2]) #technically should be looking at the next genotyped marker.
        if ( (length(unique(gt)) == 2) & (gt[1] == gt[3])) return(NA)
        if ( length(unique(gt))  == 3) return(NA)
        return(gt[2])
      })
    })
  }
  LG.f2$geno <- within(LG.f2$geno,assign(chr,my.chr))
  print(paste(chr,"NA after",sum(is.na(get(chr,LG.f2$geno)$data))))
}  

map.new <- est.map(LG.f2,verbose=T,error.prob=.01) 
save(map.new, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/map.new.Rdata")

LG.f2 <- replace.map(LG.f2, map.new)
LG.f2.after.crossover <- LG.f2

plot.map(LG.f2.after.crossover, alternate.chrid = T) # the old genetic map
plot.map(LG.f2.before.crossover,LG.f2.after.crossover, alternate.chrid = T) # genetic map comparison 
save(LG.f2.after.crossover, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/LG.f2.after.crossover.Rdata")
```

### initial QTL analysis (practice)
```{r}
# LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover, step=2)
# out.em <- scanone(LG.f2.after.crossover, method="em")
# out.hk <- scanone(LG.f2.after.crossover, method="hk")
# plot(out.em, out.hk, col=c("blue","red")) 
```

### follow Julin's CSHL code 
```{r}
load("~/F2/data/QTL_analysis/LG.f2.after.crossover.Rdata")
summary(LG.f2.after.crossover)
# take a look at the geno and pheno data as well as the rf plot (rf plot shows further refinement is required)
plot(LG.f2.after.crossover)
plot.rf(LG.f2.after.crossover)

# look for possible genotyping errors
# LG.f2.after.crossover <- calc.errorlod(LG.f2.after.crossover, error.prob=0.01) # takes too long time, leave for later... 
# top.errorlod(LG.f2.after.crossover)

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation? 
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability? 

# map
# start from one dimensional scan on imputed genotypes 
# permute the data to set a significance threshold 

sfInit(parallel = TRUE, cpus = parallel::detectCores()) 
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

scanone.perm.imp <- 
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here 
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish 

sfStop() 

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)

#note method "em" = interval mapping; "mr" = marker regression
#here we use method "imp" for multiple imputation.
  #advantage of "imp" is better for missing genotype data
  #disadvantage is that it is slower.  Not a big deal on current computers.
# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=15,method="imp") # 
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")
abline(h=scanone.perm.imp[["Erucic_acid"]],lty=2) #add permuation threshold

# Oleic acid 
scanone.imp.Oleic <- scanone(LG.f2.after.crossover,pheno.col=8,method="imp") # 
plot(scanone.imp.Oleic,bandcol="gray90", main="Oleic_acid")
abline(h=scanone.perm.imp[["Oleic_acid"]],lty=2) #add permuation threshold
```

### run one dimeonsional mapping for all traits at once 
```{r}
scanone.imp <- 
lapply(seq_along(LG.f2.after.crossover$pheno), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
}) 

names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)

png("~/F2/output/QTL_analysis/figure/QTL_one_dim.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()  
```

### cim mapping (composite interval mapping)
a more sophisticated model is to use the most significant markers as covariates during a 1D scan.  This is known as composite interval mapping (CIM) and is implmented using the function cim 

```{r}
cim.qtl <- 
lapply(seq_along(LG.f2.after.crossover$pheno), function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
}) 
# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)

cim.perm <- cim(LG.f2.after.crossover,n.marcovar=5,method="em",n.perm=1000) #takes almost an hour 
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.Rdata")
summary(cim.perm)
cim.perm95 <- summary(cim.perm)[1] 

sfInit(parallel = TRUE, cpus = parallel::detectCores()) 
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)  

cim.perm <- 
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    message(trait) # message doesn't work in here either 
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait, 
               n.marcovar=5, 
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish 

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)

# plot out result and save plot 
png("~/F2/output/QTL_analysis/figure/QTL_cim_1.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2)
}

dev.off()  
# more QTL found for cim method 
```

### output result from scanone & cim 
```{r}



```


### 2D scan
The above methods only evaluate the evidence for a QTL one location a time.  It is possible to instead scan two locations at once.  This can be particularly advantageous in identifying QTL if there is epistasis.

```{r}

```




















