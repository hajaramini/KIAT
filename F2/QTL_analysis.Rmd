---
title: "QTL_analysis"
author: "Ruijuan Li"
date: "9/26/2017"
output: 
  html_document: 
    keep_md: yes
---

Goal of this project: to map QTL using the genetic map that I constructed from F2 mapping population created from Da-Ae & Da-Ol-1 

```{r}
library(tidyverse)
library(qtl)
library(snowfall)
library(ggrepel) 
```

### reformat file with geno and pheno info
```{r}
# geno data 
F2_geno_data_2_Ae_Ol_new <- read.table("~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/F2_geno_data_2_Ae_Ol_new.txt")
dim(F2_geno_data_2_Ae_Ol_new) # 3443 166 
F2_geno_data_2_Ae_Ol_new[1:10, 1:10]

# pheno data 
pheno <- read.csv("~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/F2_Phenotype_Bnapus_all.csv", header = T, row.names = 1)
dim(pheno) # 42 166 
pheno[1:10, 1:10]
rownames(pheno) <- gsub("\ ", "_", rownames(pheno))
rownames(pheno) <- gsub("-", "_", rownames(pheno))
rownames(pheno) <- gsub("\\.", "_", rownames(pheno)) 

# combine geno & pheno data for QTL analysis 
colnames(F2_geno_data_2_Ae_Ol_new) <- gsub("X", "ID_", colnames(F2_geno_data_2_Ae_Ol_new))
F2_geno_data_2_Ae_Ol_new[1:10, 1:10]

F2_geno_data_2_Ae_Ol_new.t <- as.data.frame(t(F2_geno_data_2_Ae_Ol_new))
F2_geno_data_2_Ae_Ol_new.t$ID <- rownames(F2_geno_data_2_Ae_Ol_new.t)
pheno.t <- as.data.frame(t(pheno)) 
pheno.t$ID <- rownames(pheno.t)

F2_geno_data_2_Ae_Ol_new.2 <- 
F2_geno_data_2_Ae_Ol_new.t %>% 
  left_join(pheno.t) %>% 
  select(-ID)  

dim(F2_geno_data_2_Ae_Ol_new.2) # 166 3485 
F2_geno_data_2_Ae_Ol_new.2[1:10, 3440:3485] 
F2_geno_data_2_Ae_Ol_new.2 <- t(F2_geno_data_2_Ae_Ol_new.2)

write.table(F2_geno_data_2_Ae_Ol_new.2, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/F2_geno_data_2_Ae_Ol_new.2.txt")
# change file format in linux 
# cat F2_geno_data_2_Ae_Ol_new.2.txt | sed 's/"//g' | awk '{first = $1; $1 = ""; print $0}' > tmp
# tail -3485 tmp > tmp.1 

write.table(rownames(F2_geno_data_2_Ae_Ol_new.2), file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/marker_info.txt" )
# cat marker_info.txt | awk '{print "*"$2}' | tail -3485 | sed 's/"//g' > marker_info_reform.txt

# paste marker_info_reform.txt tmp.1  | tr "\t" "\ " > F2_geno_for_one_map.txt
# cat ../../header_one_map_input F2_geno_for_one_map.txt > F2_geno_for_one_map_final.txt 
# change header info: maker number to the right marker number 
```

### load data 
```{r} 
LG.f2 <- read.cross("mm", file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/F2_geno_for_one_map_final.txt", mapfile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/LG.f2.madmapper.map")
```

### re-estimate map
```{r}
LG.f2

LG.f2.before.crossover <- LG.f2

for (chr in names(LG.f2$geno)) { # for each chromosome in cross genotype data
  my.chr <- get(chr,LG.f2$geno) # return the genotype data, including data & map
  print(paste(chr,"NA before",sum(is.na(my.chr$data)))) 
  if(ncol(my.chr$data) > 3) { 
    my.chr$data[,2:(ncol(my.chr$data)-1)] <- sapply(2:(ncol(my.chr$data)-1),function(i) {
      apply(my.chr$data[,(i-1):(i+1)],1,function(gt) {
        if (any(is.na(gt))) return(gt[2]) #technically should be looking at the next genotyped marker.
        if ( (length(unique(gt)) == 2) & (gt[1] == gt[3])) return(NA)
        if ( length(unique(gt))  == 3) return(NA)
        return(gt[2])
      })
    })
  }
  LG.f2$geno <- within(LG.f2$geno,assign(chr,my.chr))
  print(paste(chr,"NA after",sum(is.na(get(chr,LG.f2$geno)$data))))
}  

map.new <- est.map(LG.f2,verbose=T,error.prob=.01) 
save(map.new, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/map.new.Rdata")

LG.f2 <- replace.map(LG.f2, map.new)
LG.f2.after.crossover <- LG.f2

plot.map(LG.f2.after.crossover, alternate.chrid = T) # the old genetic map
plot.map(LG.f2.before.crossover,LG.f2.after.crossover, alternate.chrid = T) # genetic map comparison 
save(LG.f2.after.crossover, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/QTL_analysis/LG.f2.after.crossover.Rdata")
```   

### follow Julin's CSHL code 
```{r}
load("~/F2/data/QTL_analysis/LG.f2.after.crossover.Rdata")
summary(LG.f2.after.crossover)
# take a look at the geno and pheno data as well as the rf plot (rf plot shows further refinement is required)
plot(LG.f2.after.crossover)
plot.rf(LG.f2.after.crossover)

# look for possible genotyping errors
# LG.f2.after.crossover <- calc.errorlod(LG.f2.after.crossover, error.prob=0.01) # takes too long time, leave for later... 
# top.errorlod(LG.f2.after.crossover)

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation? 
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability? 

# map
# start from one dimensional scan on imputed genotypes 
# permute the data to set a significance threshold 

sfInit(parallel = TRUE, cpus = parallel::detectCores()) 
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

scanone.perm.imp <- 
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here 
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish 

sfStop() 

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)

#note method "em" = interval mapping; "mr" = marker regression
#here we use method "imp" for multiple imputation.
  #advantage of "imp" is better for missing genotype data
  #disadvantage is that it is slower.  Not a big deal on current computers.
# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=15,method="imp") # 
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")
abline(h=scanone.perm.imp[["Erucic_acid"]],lty=2) #add permuation threshold

# Oleic acid 
scanone.imp.Oleic <- scanone(LG.f2.after.crossover,pheno.col=8,method="imp") # 
plot(scanone.imp.Oleic,bandcol="gray90", main="Oleic_acid")
abline(h=scanone.perm.imp[["Oleic_acid"]],lty=2) #add permuation threshold
```

### run one dimeonsional mapping for all traits at once 
```{r}
scanone.imp <- 
lapply(seq_along(LG.f2.after.crossover$pheno), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
}) 

names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)

png("~/F2/output/QTL_analysis/figure/QTL_one_dim.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()  
```

### cim mapping (composite interval mapping)
a more sophisticated model is to use the most significant markers as covariates during a 1D scan.  This is known as composite interval mapping (CIM) and is implmented using the function cim 

```{r}
cim.qtl <- 
lapply(seq_along(LG.f2.after.crossover$pheno), function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
}) 
# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)

cim.perm <- cim(LG.f2.after.crossover,n.marcovar=5,method="em",n.perm=1000) #takes almost an hour 
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.Rdata")
summary(cim.perm)
cim.perm95 <- summary(cim.perm)[1] 

sfInit(parallel = TRUE, cpus = parallel::detectCores()) 
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)  

cim.perm <- 
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    message(trait) # message doesn't work in here either 
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait, 
               n.marcovar=5, 
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish 

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)

# plot out result and save plot 
png("~/F2/output/QTL_analysis/figure/QTL_cim_1.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2)
}

dev.off()  
# more QTL found for cim method 

save(cim.qtl, cim.perm, file = "~/F2/output/QTL_analysis/cim.Rdata")
save(scanone.imp, scanone.perm.imp, file = "~/F2/output/QTL_analysis/scanone.Rdata")
```

### output result from scanone & cim 
```{r}
load("~/F2/output/QTL_analysis/cim.Rdata")
load("~/F2/output/QTL_analysis/scanone.Rdata")

cim.qtl[[1]]$chr
cim.qtl[[1]]$pos
plot(cim.qtl[[1]]$lod) 

plot(cim.qtl[[1]], chr=c(19))  

qtl_plot(input = cim.qtl[[1]]) 

qtl_plot(input = rbind(data.frame(cim.qtl[[1]], method = "EM algorithm"), 
                       data.frame(cim.qtl[[2]], method = "Haley-Knott regression"), 
                       data.frame(cim.qtl[[3]], method = "Multiple imputation")), 
         chrs = c(1, 4), 
         lod = cim.perm[[1]], 
         rug = TRUE) 

ggplot(cim.qtl, aes(cumsum(gen_map), lod, colour=chr) + geom_point())

```


### 2D scan
The above methods only evaluate the evidence for a QTL one location a time.  It is possible to instead scan two locations at once.  This can be particularly advantageous in identifying QTL if there is epistasis.

```{r}

```

### appendix 
```{r}

qtl_plot <- function(input,              # data frame input from scanone
                     mult.pheno = FALSE, # multiple phenotypes?
                     model = "normal",   # model used in scanone
                     chrs = NA,          # chromosomes to display
                     lod = NA,           # LOD threshold
                     rug = FALSE,        # plot marker positions as rug?
                     ncol = NA,          # number of columns for facetting
                     labels = NA         # optional dataframe to plot QTL labels
                     ) {
                     
                  # if we have multiple phenotypes and/or a 2part model, gather input
                  if (mult.pheno & model == "2part") {
                    input <- gather(input, group, lod, grep("pheno", colnames(input)))
                  } else if (mult.pheno) {
                    input <- gather(input, group, lod, grep("pheno", colnames(input)))
                  } else if (model == "2part") {
                    input <- gather(input, method, lod, lod.p.mu:lod.mu)
                  }
    
                  # if not all chromosomes should be displayed, subset input
                  if (!is.na(chrs)[1]) {
                    input <- input[as.character(input$chr) %in% chrs, ]
                  }

                  # if there is more than one LOD column, gather input
                  if (!any(colnames(input) == "lod")) {
                    input$lod <- input[, grep("lod", colnames(input))]
                  }

                  # if no number of columns for facetting is defined, plot all in one row
                  if (is.na(ncol)) {
                    ncol <- length(unique(input$chr))
                  }

                  # if labels are set and there is no name column, set from rownames
                  if (!is.na(labels)[1]) {
                    if (is.null(labels$name)) {
                      labels$name <- rownames(labels)
                    }
                  }

                  # plot input data frame position and LOD score
                  plot <- ggplot(input, aes(x = pos, y = lod)) + {

                    # if LOD threshold is given, plot as horizontal line
                    if (!is.na(lod)[1] & length(lod) == 1) geom_hline(yintercept = lod, linetype = "dashed")
                  } + {

                    if (!is.na(lod)[1] & length(lod) > 1) geom_hline(data = lod, aes(yintercept = lod, linetype = group))
                  } + {

                    # plot rug on bottom, if TRUE
                    if (rug) geom_rug(size = 0.1, sides = "b")
                  } + {

                    # if input has column method but not group, plot line and color by method
                    if (!is.null(input$method) & is.null(input$group)) geom_line(aes(color = method), size = 2, alpha = 0.6)
                  } + {

                    # if input has column group but not method, plot line and color by group
                    if (!is.null(input$group) & is.null(input$method)) geom_line(aes(color = group), size = 2, alpha = 0.6)
                  } + {

                    # if input has columns method and group, plot line and color by method & linetype by group
                    if (!is.null(input$group) & !is.null(input$method)) geom_line(aes(color = method, linetype = group), size = 2, alpha = 0.6)
                  } + {

                    # set linetype, if input has columns method and group
                    if (!is.null(input$group) & !is.null(input$method)) scale_linetype_manual(values = c("solid", "twodash", "dotted"))
                  } + {

                    # if input has neither columns method nor group, plot black line
                    if (is.null(input$group) & is.null(input$method)) geom_line(size = 2, alpha = 0.6)
                  } + {

                    # if QTL positions are given in labels df, plot as point...
                    if (!is.na(labels)[1]) geom_point(data = labels, aes(x = pos, y = lod))
                  } + {

                    # ... and plot name as text with ggrepel to avoid overlapping
                    if (!is.na(labels)[1]) geom_text_repel(data = labels, aes(x = pos, y = lod, label = name), nudge_y = 0.5)
                  } + 
                    # facet by chromosome
                    facet_wrap(~ chr, ncol = ncol, scales = "free_x") +
                    # minimal plotting theme
                    theme_minimal() +
                    # increase strip title size
                    theme(strip.text = element_text(face = "bold", size = 12)) +
                    # use RcolorBrewer palette
                    scale_color_brewer(palette = "Set1") +
                    # Change plot labels
                    labs(x = "Chromosome",
                         y = "LOD",
                         color = "",
                         linetype = "")

                  print(plot)
} 
```


















