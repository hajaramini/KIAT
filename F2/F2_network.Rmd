---
title: "F2_network"
author: "Ruijuan Li"
date: "12/8/2017"
output: html_document
---

Goal of this script is to build networks for B.napus F2 RNAseq data using WGCNA, referred to Julin's analysis on his rapa data https://github.com/MaloofLab/BrapaNetworks 

### load libs
```{r}
library(WGCNA)
library(tidyverse)
library(edgeR)
library(DESeq2)
library(magrittr)
library(gplots)
options(stringsAsFactors = FALSE)
```

### read count load, and process read count for WGCNA  
```{r}
load("~/F2/output/vstMat.f2.Rdata")
dim(vstMat.f2) # 56180   166 

# follow Julin's script https://github.com/MaloofLab/BrapaNetworks/blob/master/ProcessCounts.Rmd 
read_count_F2 <- read.table("~/F2/data/est.counts.F2.tsv.gz", header = T, row.names = 1)
dim(read_count_F2) # 101040    166

# load in batch information 
batchA <- read.csv("~/F2/data/network_analysis/F2_batchA.csv")
batchB <- read.csv("~/F2/data/network_analysis/F2_batchB.csv")
batchC <- read.csv("~/F2/data/network_analysis/F2_batchC.csv")

batchA <- data.frame(sample_ID = batchA$No..of.Sowing, 
                     batch = rep("A", nrow(batchA)))

batchB <- data.frame(sample_ID = batchB$No..of.Sowing, 
                     batch = rep("B", nrow(batchB)))

batchC <- data.frame(sample_ID = batchC$No..of.Sowing[1:46], 
                     batch = rep("C", 46))

batch_info <- rbind(batchA, batchB, batchC) 
batch_info %>% dim() # 166 2 

# combine batch information to the 
batch_info$sample_ID <- paste("Sample_F2_", batch_info$sample_ID, sep = "")
batch_info <- batch_info[match(colnames(read_count_F2), batch_info$sample_ID),] # reorder batch_info to make it the same order as read count  
all(batch_info$sample_ID == colnames(read_count_F2)) # True 

# sample description 
F2.sample <- data.frame(batch = factor(batch_info$batch), 
                        genotype = factor(batch_info$sample_ID)) 

# remove lowly expressed genes 
read.count.small <- read_count_F2[rowSums(read_count_F2 > 10) >= 166*0.25,]
dim(read.count.small) # 56180   166   

# Normalize
dge.F2 <- DGEList(counts = read.count.small, group = F2.sample$genotype)
dge.F2 <- calcNormFactors(dge.F2)
hist(dge.F2$samples$norm.factors)

batch_info$group <- batch_info$sample_ID 
dge.F2$samples %>% 
  left_join(batch_info, by = "group") %>% 
  ggplot() + 
  geom_histogram(aes(x = norm.factors, fill = batch))

# since there is very big batch effect for batch B, I decided to analyze batch A+C and batch B seperately. 

# get sepereate gene expression data for A+C and B 
# A+C 
read_count_F2.AC <- read_count_F2[,colnames(read_count_F2) %in% batch_info$sample_ID[batch_info$batch == "A" | batch_info$batch == "C"]] 
read_count_F2.AC %>% dim() # 101040    125

# filter lowly expressed genes 
read.count.small.F2.AC <- read_count_F2.AC[rowSums(read_count_F2.AC > 10) >= 125*0.25,]
dim(read.count.small.F2.AC) # 57376   125 

# vst transformation of the two subset of data, these transformed values will be used in WGCNA analysis 
# batch AC 
read.count.sample.AC <- data.frame(group=factor(F2.sample[F2.sample$batch == "A" | F2.sample$batch == "C",]$genotype), 
                                   batch=factor(F2.sample[F2.sample$batch == "A" | F2.sample$batch == "C",]$batch)) 


all(read.count.sample.AC$genotype == colnames(read.count.small.F2.AC)) # True, same order 

dds.f2.AC <- DESeqDataSetFromMatrix(countData = round(read.count.small.F2.AC), colData = read.count.sample.AC, design = ~group)  
vsd.f2.AC <- varianceStabilizingTransformation(dds.f2.AC)
vstMat.f2.AC <- assay(vsd.f2.AC) 
colnames(vstMat.f2.AC) <- colnames(read.count.small.F2.AC) 
save(vstMat.f2.AC, file = "~/F2/output/vstMat.f2.AC.Rdata") 

### get genes that are differentially expressed among the different genotypes using edgeR 
# normalize 
dge.read.count <- DGEList(counts=read.count.small.F2.AC, group=read.count.sample.AC$group)
dge.read.count <- calcNormFactors(dge.read.count, method = "TMM")
hist(dge.read.count$samples$norm.factors)

# # GLM model w/o reps 
design.read.count <- model.matrix(~group, data = read.count.sample.AC)
bcv <- 0.4
dge.read.count$common.dispersion <- bcv ^ 2 

### mds plot 
mds <- plotMDS(dge.read.count, method = "bcv",labels = dge.read.count$samples$group)
x <- as.data.frame(mds$x)
y <- as.data.frame(mds$y)
distance_matrix <- merge(x, y, by="row.names")
distance_matrix$Row.names

# merge with batch info 
batch_info %>% head()
colnames(distance_matrix)[1] <- "sample_ID"
distance_matrix.all <- merge(distance_matrix, batch_info, by = "sample_ID")

p.mds.batch <- ggplot(data=distance_matrix.all, aes(mds$x, mds$y, color=factor(batch)))
p.mds.batch <- p.mds.batch + geom_point(size=1) 
p.mds.batch <- p.mds.batch + scale_color_brewer(type="qual",palette="Set1")
p.mds.batch 
# a clear batch effect, will this affect WGCNA result? 

## fit model & look for DEGs
fit.read.count <- glmFit(dge.read.count, design.read.count)

# detect DEGs, finding genes different between any of the two lines 
lrt.read.count <- glmLRT(fit.read.count, coef=2:125) # find any genes that are differentially expressed compared to the reference genotype (the intercept) 
topTags(lrt.read.count)
DEgene.F2 <- topTags(lrt.read.count,n = Inf)$table[topTags(lrt.read.count,n = Inf)$table$FDR<1e-05,]
dim(DEgene.F2) # 21513   128 

### pick genes which have differential expression across samples for WGCNA (FDR < 1e-05)
vstMat.f2.AC.WGCNA <- vstMat.f2.AC[rownames(vstMat.f2.AC) %in% rownames(DEgene.F2),]
dim(vstMat.f2.AC.WGCNA) # 21513   125 
save(vstMat.f2.AC.WGCNA, file ="~/F2/output/vstMat.f2.AC.WGCNA.Rdata")
```

### WGCNA for network  
refer to https://github.com/MaloofLab/BrapaNetworks/blob/master/WGCNA_CR.Rmd 
```{r}
load("~/F2/output/vstMat.f2.AC.WGCNA.Rdata")

# phenotype data F2 for batch A & batch C


# transform expression data 
head(vstMat.f2.AC.WGCNA[,1:6])
vstMat.f2.AC.WGCNA.t <- t(vstMat.f2.AC.WGCNA)
head(vstMat.f2.AC.WGCNA.t[,1:6]) 

# check sample quality 
gag.CR <- goodSamplesGenes(vstMat.f2.AC.WGCNA.t, verbose = 3)
gag.CR$allOK

# cluster samples to look for outliers
sampleTREE.CR <- hclust(dist(vstMat.f2.AC.WGCNA.t), method = "average")
plot(sampleTREE.CR,cex=.6) # should be able to color based on batch, see whether outliers are due to batch effect 
heatmap.2(vstMat.f2.AC.WGCNA.t,Rowv=as.dendrogram(sampleTREE.CR), scale="col", trace="none")
# are there spurious sample that seem different from other samples? outliers? 

# soft threshold
powers <- c(c(1:10), seq(from = 12, to=20, by=2))
sft <- pickSoftThreshold(vstMat.f2.AC.WGCNA.t, powerVector = powers, verbose = 5)

sizeGrWindow(9, 5)
par(mfrow = c(1,2))
cex1 <- 0.9
# Scale-free topology fit index as a fCRction of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a fCRction of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red") 

# choose 14 
softPower <- 14
adjacency <- adjacency(vstMat.f2.AC.WGCNA.t, power = softPower)
# Turn adjacency into topological overlap
TOM <- TOMsimilarity(adjacency);
dissTOM <- 1-TOM 

# Call the hierarchical clustering fCRction
geneTree <- hclust(as.dist(dissTOM), method = "average")
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)

# define modules 
# We like large modules, so we set the minimum module size relatively high:
minModuleSize <- 30;
# Module identification using dynamic tree cut:
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,
                             deepSplit <- 2, pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize);
table(dynamicMods)

# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors CRderneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")


# merge similar modules
# Calculate eigengenes
MEList <- moduleEigengenes(vstMat.f2.AC.WGCNA.t, colors = dynamicColors)
MEs <- MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss <- 1-cor(MEs);
# Cluster module eigengenes
METree <- hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# merge with correlation > 0.8

MEDissThres = 0.2
# Plot the cut line into the dendrogram
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
abline(h=MEDissThres, col = "red")
# Call an automatic merging fCRction
merge = mergeCloseModules(vstMat.f2.AC.WGCNA.t, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs

# compare pre and post merge

sizeGrWindow(12, 9)
#pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()

# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs

head(MEs)
dim(MEs)
dim(blups.CR) 
rownames(expr.data.CR.t)
rownames(MEs)
rownames(MEs) <- rownames(expr.data.CR.t)
head(blups.CR)
```



