---
title: "QTL_analysis_flipped"
output: html_document
---

### purpose of this script is to finish QTL analysis with several LG flipped 

```{r}
### load lib
library(tidyverse)
library(qtl) 
library(snowfall)
library(ggrepel) 
library(Biostrings) 
source("~/KIAT/function_BnRNAseq.R")  

### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/F2/data/QTL_analysis/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/F2/data/QTL_analysis/F2.pheno.csv",
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
map.summary <- summaryMap(LG.f2.after.crossover) # 2884
write.csv(map.summary, file = "~/F2/output/QTL_analysis/map.summary.csv")   

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover") 
sfLibrary(qtl)

system.time(
scanone.perm.imp <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno), function(trait){
    print(trait) # print doesn't work in here
    tmp <-scanone(LG.f2.after.crossover,pheno.col = trait, method="imp",n.perm=1000, n.cluster = 16)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes 40 mins to finish
)
sfStop()

names(scanone.perm.imp) <- colnames(LG.f2.after.crossover$pheno)
save(scanone.perm.imp, file = "~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")

# Erucic acid 
scanone.imp.Erucic <- scanone(LG.f2.after.crossover,pheno.col=15,method="imp") #
plot(scanone.imp.Erucic,bandcol="gray90", main="Erucic_acid")
abline(h=scanone.perm.imp[["Erucic_acid"]],lty=2) #add permuation threshold

# Oleic acid
scanone.imp.Oleic <- scanone(LG.f2.after.crossover,pheno.col=8,method="imp") #
plot(scanone.imp.Oleic,bandcol="gray90", main="Oleic_acid")
abline(h=scanone.perm.imp[["Oleic_acid"]],lty=2) #add permuation threshold

system.time(
scanone.imp <-
lapply(seq_along(LG.f2.after.crossover$pheno[1:43]), function(trait) {
  print(trait)
  scanone(LG.f2.after.crossover,pheno.col=trait,method="imp")
})
)
names(scanone.imp) <- colnames(LG.f2.after.crossover$pheno)[1:43]

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(scanone.imp)){
  plot(scanone.imp[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp[[i]],lty=2)
}

dev.off()

save(scanone.imp, file = "~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl <-
lapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait) {
  print(trait)
  cim(LG.f2.after.crossover, n.marcovar=5, pheno.col=trait,method="em")
})

cim.qtl[["vaccenic_acid"]] 

# here we use the interval mapping method "em" as this is how cim was originaly implmented.the n.marcovar= argument defines the maximum number of marker covariates to use.
names(cim.qtl) <- colnames(LG.f2.after.crossover$pheno)[1:43]

sfInit(parallel = TRUE, cpus = 4)
sfExport("LG.f2.after.crossover")
sfLibrary(qtl)

cim.perm <-
  sfLapply(seq_along(LG.f2.after.crossover$pheno)[1:43], function(trait){
    message(trait) # message doesn't work in here either
    tmp <- cim(LG.f2.after.crossover,
               pheno.col = trait,
               n.marcovar=5,
               method="em",
               n.perm=1000)
    summary(tmp)[1] # #keep the 95th percentile for future use.This corresponds to p <0.05
  }) # takes almost 4 hours to finish

sfStop() 

names(cim.perm) <- colnames(LG.f2.after.crossover$pheno)[1:43]

# plot out result and save plot
png("~/F2/output/QTL_analysis/figure/QTL_cim_1_flipped.png", width=25, height=15, units="in", res=300)
par(mfrow=c(6,7))

for (i in names(cim.qtl)){
  plot(cim.qtl[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm[[i]],lty=2)
}

dev.off()
# more QTL found for cim method

save(cim.qtl, file = "~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
save(cim.perm, file = "~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata") 
```

### need a script to tell me which LG has significant QTL for different traits 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.qtl.result <- 
lapply(names(cim.qtl), function(trait) {
  as.numeric(unique(cim.qtl[[trait]][(cim.qtl[[trait]]$lod > cim.perm[[trait]]),]$chr))
})

im.qtl.result <- 
lapply(names(scanone.imp), function(trait) {
  as.numeric(unique(scanone.imp[[trait]][(scanone.imp[[trait]]$lod > scanone.perm.imp[[trait]]),]$chr))
})

names(cim.qtl.result) <- names(cim.qtl)
names(im.qtl.result) <- names(scanone.imp) 
unlist(cim.qtl.result)
unlist(im.qtl.result)  
``` 

### get genes under QTL for different traits, use cim result, if there is no cim result, using scanone result 
```{r} 
load("~/F2/output/QTL_analysis/QTL_result_all.Rdata")

scanone.perm.imp.all %>% length()
scanone.imp.all %>% length() 
cim.perm.all %>% length()
cim.qtl.all %>% length()

### scanone 
threshold.95 <- tibble(perm.threshold = bind_rows(scanone.perm.imp.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(scanone.perm.imp.all)))
threshold.95

scanone.qtl.2 <-  
bind_cols(scanone.imp.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(scanone.qtl.2) <- rownames(scanone.imp.all$Crude_oil_contents)
colnames(scanone.qtl.2)[3:ncol(scanone.qtl.2)] <- names(scanone.imp.all)

scanone.gather <- scanone.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

scanone.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- scanone.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 33

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.scanone %>% dim() # 33 6 

### cim
threshold.95 <- tibble(perm.threshold = bind_rows(cim.perm.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(cim.perm.all)))
threshold.95

cim.qtl.2 <-  
bind_cols(cim.qtl.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(cim.qtl.2) <- rownames(cim.qtl.all$Crude_oil_contents)
colnames(cim.qtl.2)[3:ncol(cim.qtl.2)] <- names(cim.qtl.all)

cim.gather <- cim.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

cim.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- cim.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n()) 
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(cim.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 26

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.cim %>% dim() # 26 6  

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result %>% dim()
colnames(bayesint.result)

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:7)] <- bayesint.result[i, c(8:12)]
  }
}

bayesint.result <- bayesint.result[,1:7] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 7

# annotate QTL  
load("~/Reference/B.napus/BnapusAnnotation.Rdata") 

traitQTL.annotated <- lapply(1:nrow(bayesint.result),function(row) { # for each trait/module 
  qtl <- bayesint.result[row,]  
  results <- subset(BnapusAnnotation, chrom==qtl$chr &
                    start >= qtl$start & # genes which fall into the QTL interval 
                    end <= qtl$end)
} 
)  
names(traitQTL.annotated) <- bayesint.result$trait 

traitQTL.annotated <- bind_rows(traitQTL.annotated,.id="trait") %>% # combine list into data.frame 
  mutate(chrom=as.character(chrom)) %>%
  left_join(bayesint.result,by=c("trait","chrom"="chr")) #get eQTL LOD

traitQTL.annotated <- 
traitQTL.annotated %>% 
  mutate(start = start.y, end = end.y) %>% 
  dplyr::select(-start.x, -end.x, -start.y, -end.y, -min_eQTL_LOD, -max_eQTL_LOD) 

traitQTL.annotated %>% dim() # 18647     9 

## get GO term for each gene
load("~/Reference/B.napus/napus_GO_combined.Rdata") # there is one colomn hiding... 

colnames(traitQTL.annotated)[3] <- "gene_ID"

traitQTL.annotated <- 
traitQTL.annotated %>% 
  left_join(napus_GO_combined) 

traitQTL.annotated %>% dim() #  18647    11 
save(traitQTL.annotated, file =  "~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata") 
```

# discrepency between previous result & current QTL result, FLC gene not located in the interval for days_to_flower anymore 
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

### current one 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 
#        start      end chrom
# 1   15367151 15942430   A10
# 130 25340726 32476288   C06

traitQTL.annotated %>% 
  filter(trait == "days_to_bolt") %>% 
  dplyr::select(start, end, chrom)%>% 
  unique()  

#        start      end chrom
# 1   14613931 15142872   A10
# 134 22643132 31785732   C06

traitQTL.annotated[which(traitQTL.annotated$AGI == "AT5G10140" ),]

gff.mRNA[gff.mRNA$gene_ID == "BnaA10g22080D",] 
#   CHROM    start      end       gene_ID
#   chrA10 14998617 15003197 BnaA10g22080D

######## previous one 
load("~/F2/output/QTL_analysis/traitQTL.annotated.Rdata") 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower") %>% 
  dplyr::select(start, end, chrom) %>% 
  unique() 

#        start      end chrom
#  14772310 15942430   A10
#  25340726 32476288   C06
```


### check important genes
```{r}
load("~/F2/output/QTL_analysis/traitQTL.annotated.flipped.Rdata")

traitQTL.annotated %>% dim() #  18647    11 
traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") # cool, FLC gene is on A10  

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT5G10140") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G00650") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16280") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  # filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(AGI == "AT4G16845") # cool, FLC gene is on A10   

traitQTL.annotated %>% 
  filter(trait == "days_to_flower" | trait == "days_to_bolt") %>% 
  filter(chrom == "C06") %>% 
  View() # cool, FLC gene is on A10   
 
# besides FLC, don't see other obvious flowering related genes here 
```  

### plot for paper 
```{r}
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm)[c(1:15, 17, 21:55)] 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)[c(1:15, 17, 21:55)]
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))[c(1:15, 17, 21:55)] 
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)[c(1:15, 17, 21:55)] 

cim.qtl.all[["vaccenic_acid"]] <- cim.qtl.all$vaccenic_acid[[1]]
cim.qtl.all[["vaccenic_acid"]] %>% class()
save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all.Rdata")

png("~/F2/output/QTL_analysis/figure/QTL_one_dim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(scanone.imp.all)){
  plot(scanone.imp.all[[i]],bandcol="gray90", main=i)
  abline(h=scanone.perm.imp.all[[i]],lty=2)
} 

dev.off()  

png("~/F2/output/QTL_analysis/figure/QTL_cim_flipped.png", width=30, height=30, units="in", res=300)
par(mfrow=c(11,5))

for (i in names(cim.qtl.all)){
  plot(cim.qtl.all[[i]],bandcol="gray90", main=i)
  abline(h=cim.perm.all[[i]],lty=2)
}

dev.off()  

cim.qtl.all[["vaccenic_acid"]] 
cim.perm.all[["vaccenic_acid"]] 

oil_ID <- c("Palmitic_acid", "Stearic_acid", "Oleic_acid", "vaccenic_acid", "Linoleic_acid", "Arachidic_acid", "Linolenic_acid", "Erucic_acid", "cis_11_Eicosenoic_acid", "Behenic_acid")

oil.plot <- list()
for (i in oil_ID){
  oil.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A08", "C03"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}

library(cowplot)
get_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}
legend <- get_legend(oil.plot[[1]]$plot)

oil.plot.2 <-plot_grid(
  oil.plot[[1]]$plot+theme(legend.position="none"),
  oil.plot[[2]]$plot+theme(legend.position="none"), 
  oil.plot[[3]]$plot+theme(legend.position="none"),
  oil.plot[[4]]$plot+theme(legend.position="none"),
  oil.plot[[5]]$plot+theme(legend.position="none"),
  oil.plot[[6]]$plot+theme(legend.position="none"),
  oil.plot[[7]]$plot+theme(legend.position="none"),
  oil.plot[[8]]$plot+theme(legend.position="none"),
  oil.plot[[9]]$plot+theme(legend.position="none"),
  oil.plot[[10]]$plot+theme(legend.position="none"),
  ncol=2, nrow = 5,labels=c("","","",""))  

oil.plot.3 <- plot_grid(oil.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
oil.plot.3 

ggsave(oil.plot.3, filename = "~/F2/output/QTL_analysis/figure/oil.plot.3.png", width = 12, height = 12)

growth_ID <- c("days_to_bolt", "days_to_flower", "leaf_number_2015_12_28", "leaf_number_2016_03_21", "lobe_number_2016_01_21", "root_weight_2016_05_13", "height_Hmax", "leaf_number_I", "lobe_number_I", "plant_height_2016_05_13") 
               
growth.plot <- list() 
for (i in growth_ID){
  growth.plot[[i]] <- qtl_plot(input = rbind(data.frame(cim.qtl.all[[i]], method = "cim"), 
                       data.frame(scanone.imp.all[[i]], method = "scanone")),
         chrs = c("A10", "C06"), 
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[i]],
                                  scanone.perm.imp.all[[i]])), 
         rug = TRUE, 
         labels = NA, 
         title = i) 
}   

growth.plot.2 <-plot_grid( 
  growth.plot[[1]]$plot+theme(legend.position="none"),
  growth.plot[[2]]$plot+theme(legend.position="none"), 
  growth.plot[[3]]$plot+theme(legend.position="none"),
  growth.plot[[4]]$plot+theme(legend.position="none"),
  growth.plot[[5]]$plot+theme(legend.position="none"), 
  growth.plot[[6]]$plot+theme(legend.position="none"),
  growth.plot[[7]]$plot+theme(legend.position="none"),
  growth.plot[[8]]$plot+theme(legend.position="none"),
  growth.plot[[9]]$plot+theme(legend.position="none"),
  growth.plot[[10]]$plot+theme(legend.position="none"),
  # legend, 
  ncol=2, nrow = 5,labels=c("","","",""))  

growth.plot.3 <- plot_grid(growth.plot.2, legend, rel_heights = c(45, 1), ncol = 1, nrow = 2)
growth.plot.3 

ggsave(growth.plot.3, filename = "~/F2/output/QTL_analysis/figure/growth.plot.3.png", width = 12, height = 12)

#### make scanone and CIM plot for each trait 
load("~/F2/output/QTL_analysis/cim.perm.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/cim.qtl.43traits.flipped.Rdata")
load("~/F2/output/QTL_analysis/scanone.perm.imp.43traits.flipped")
load("~/F2/output/QTL_analysis/scanone.imp.43traits.flipped")

cim.perm.all <- cim.perm
cim.qtl.all <- cim.qtl
scanone.perm.imp.all <- scanone.perm.imp
scanone.imp.all <- scanone.imp

load("~/F2/output/growth_model/scanone_growth_model_trait_flipped.Rdata")
load("~/F2/output/growth_model/cim_growth_model_trait_flipped.Rdata") 

cim.perm.all <- c(cim.perm.all, cim.perm) 
cim.qtl.all <- c(cim.qtl.all, cim_growth_model_trait.F2)
scanone.perm.imp.all <- c(scanone.perm.imp.all[1:43], as.list(lod.thrs[5,]))
scanone.imp.all <- c(scanone.imp.all, scanone_growth_model_trait.F2)

save(cim.perm.all, cim.qtl.all, scanone.perm.imp.all, scanone.imp.all, file = "~/F2/output/QTL_analysis/QTL_result_all_all.Rdata") 

qtl_all <-   
  lapply(names(cim.qtl.all), function(trait) {
    qtl_plot(input = rbind(data.frame(cim.qtl.all[[trait]], method = "cim"), 
                       data.frame(scanone.imp.all[[trait]], method = "scanone")),
         lod = data_frame(group = c("cim_threshold", "scanone_threshold"),
                          lod = c(cim.perm.all[[trait]],
                                  scanone.perm.imp.all[[trait]])), 
         rug = TRUE, 
         title = trait
         )  
  })

plots <- lapply(1:length(qtl_all), function(trait) qtl_all[[trait]]$plot)

paths <- stringr::str_c(names(cim.qtl.all), ".pdf") 
paths 
pwalk(list(paths, plots), ggsave, path = "~/F2/output/QTL_analysis/figure/", width = 15, height = 7) # save on whitney   
``` 

### redo QTL analysis for several traits which don't follow normal distribution 
```{r}
### load data and run scanone & cim
LG.f2.after.crossover <- read.cross("csvsr", genfile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/LG.f2.madmapper.final_gen_revised_flipped.csv",
                     phefile = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/data/F2.pheno.csv",
                     genotypes = c("AA", "AB", "BB")) # the only problem is that 44 phenotypes were read instead of 43, need to figure out why later

plot.map(LG.f2.after.crossover)
summaryMap(LG.f2.after.crossover) # 2884

LG.f2.after.crossover <- sim.geno(LG.f2.after.crossover,step=1,n.draws=32) # imputation
LG.f2.after.crossover <- calc.genoprob(LG.f2.after.crossover,step=1) # calculate the probability of the true underlying genotypes given the observed multipoint marker data --> for each imputed data, give a probability?

LG.f2.after.crossover$pheno %>% colnames() # Caprylic_acid, Myristic_acid, Heptadecanoic_acid, should try "2 part" model in scanone(), Survival_rate use log transformed data to get normality 

scanone_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F)

# permutation 
perm_Caprylic <- 
scanone(LG.f2.after.crossover, pheno.col = "Caprylic_acid", method = "em", model = "2part", upper = F, n.perm = 1000)

summary(perm_Caprylic)[1] # 5.632463 
summary(perm_Caprylic, alpha = 0.05)

plot(scanone_Caprylic,bandcol="gray90", main="Caprylic_acid")
abline(h=summary(perm_Caprylic)[1],lty=2) #add permuation threshold

### Myristic acid 
scanone_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F)

perm_Myristic <-
scanone(LG.f2.after.crossover, pheno.col = "Myristic_acid", method = "em", model = "2part", upper = F, n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(perm_Myristic)[1] 
summary(perm_Myristic, alpha = 0.05)

plot(scanone_Myristic,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Myristic)[1],lty=2) #add permuation threshold # same result as identified from normal model 

### Heptadecanoic_acid don't worry, to few data points 

### survival rate, transformaion won't work because a lot of 0, is there any other model for survival rate? 
hist(sqrt(LG.f2.after.crossover$pheno$Survival_rate)) 
ggplot(LG.f2.after.crossover$pheno, aes(x = Survival_rate)) + geom_histogram(bins=15) + scale_x_log10() 
min(LG.f2.after.crossover$pheno$Survival_rate, na.rm = T)  

scanone_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np")

perm_Survival_rate <-
scanone(LG.f2.after.crossover, pheno.col = "Survival_rate", model = "np", n.perm = 1000) # upper=F to indicate that in the 2part model, phenotype is the smallest observed phenotype 
summary(Survival_rate)[1] 
summary(perm_Survival_rate, alpha = 0.05) 

plot(scanone_Survival_rate,bandcol="gray90", main="Myristic_acid")
abline(h=summary(perm_Survival_rate)[1],lty=2) #add permuation threshold # same result as identified from normal model 

save(scanone_Caprylic, scanone_Myristic, scanone_Survival_rate, perm_Caprylic, perm_Myristic, file = "~/Desktop/Brassica_project/KIAT_RNA_seq/F2/output/QTL_nonnormality.Rdata") 
```

### table to summarize QTL mapping result, make R square, additive effect... 
```{r}
load("~/F2/output/QTL_analysis/QTL_result_all.Rdata")

scanone.perm.imp.all %>% length()
scanone.imp.all %>% length() 
cim.perm.all %>% length()
cim.qtl.all %>% length()

### I will use cim result as the QTL result for different traits, unless there is more QTL identified from scanone 
threshold.95 <- tibble(perm.threshold = bind_rows(scanone.perm.imp.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(scanone.perm.imp.all)))
threshold.95

scanone.qtl.2 <-  
bind_cols(scanone.imp.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(scanone.qtl.2) <- rownames(scanone.imp.all$Crude_oil_contents)
colnames(scanone.qtl.2)[3:53] <- names(scanone.imp.all)

scanone.gather <- scanone.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

scanone.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- scanone.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 33 

bayesint.result <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD)) 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.

bayesint.result %>% dim() # 33 6 
bayesint.result 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result$index <- paste(bayesint.result$trait, bayesint.result$chr, bayesint.result$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result$index <- tmp

bayesint.result.scanone <- 
bayesint.result %>% 
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.scanone %>% dim() # 33 6 

### cim result 

cim.perm.all %>% length()
cim.qtl.all %>% length()

### I will use cim result as the QTL result for different traits, unless there is more QTL identified from scanone 
threshold.95 <- tibble(perm.threshold = bind_rows(cim.perm.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(cim.perm.all)))
threshold.95 

cim.qtl.2 <-  
bind_cols(cim.qtl.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(cim.qtl.2) <- rownames(cim.qtl.all$Crude_oil_contents)
colnames(cim.qtl.2)[3:53] <- names(cim.qtl.all)

cim.gather <- cim.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

cim.gather %>% head() 

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- cim.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())
sig.chrs 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(cim.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list 
bayesint.list %>% length() # 26

bayesint.result <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD)) 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.

bayesint.result %>% dim() # 26 6 
bayesint.result 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result$index <- paste(bayesint.result$trait, bayesint.result$chr, bayesint.result$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()
tmp  

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result$index <- tmp

bayesint.result.cim <- 
bayesint.result %>% 
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.cim %>% dim() # 33 6  

### combine cim & scanone result 
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))
bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.paper <- 
bayesint.result.scanone %>% 
  full_join(bayesint.result.cim) 

### get QTL for crude oil content 
# bayesint(cim.qtl.all[["Crude_oil_contents"]], chr = "A03", expandtomarkers = T)
#                 chr       pos       lod
# chrA03_17859843 A03  93.50555 0.1145514
# chrA03_18816407 A03  98.53770 7.0615071
# chrA03_18998089 A03 100.90084 5.2894538

save(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.Rdata") 
write.csv(bayesint.result.paper, file = "~/F2/output/QTL_analysis/bayesint.result.paper.csv") 
# modify on MAC to remove QTL identified from scanone but CIM as well
bayesint.result.paper <- read.csv("~/F2/output/QTL_analysis/bayesint.result.paper.csv")

bayesint.result.paper 
# pos <- c(98.53770, bayesint.result.paper[c(-13, -19, -27, -28, -29),]$pos)
# length(pos)

### combine with file which have allele effect information 
bayesint.result.paper.2 <- read.csv("~/F2/output/QTL_analysis/bayesint.result.paper.2.csv")
bayesint.result.paper.2

write.csv(bayesint.result.paper.2, file = "~/F2/output/QTL_analysis/bayesint.result.paper.3.csv")  
```

### synteny analysis 
```{r}
library(DECIPHER)

fas <- c(Genome1="~/Desktop/Brassica_project/reference/seq1.fa",
   Genome2="~/Desktop/Brassica_project/reference/seq2.fa",
   Genome3="~/Desktop/Brassica_project/reference/seq3.fa")

# specify where to create the new sequence database
db <- "~/Desktop/"

# load the sequences from the file in a loop
for (i in seq_along(fas)) {
   Seqs2DB(fas[i], "FASTA", db, names(fas[i]))
}

# map the syntenic regions between each genome pair
synteny <- FindSynteny(db)

# print a summary of the syntenic map (optional)
synteny

# view the syntenic regions (optional)
pairs(synteny) # displays a dot plot of all pairs
plot(synteny) # displays a bar plot of adjacent pairs

# perform alignments of all pairs of genomes
DNA <- AlignSynteny(synteny, db)

# view the aligned syntenic blocks for each pair
unlist(DNA[[1]]) # Genomes 1 and 2
unlist(DNA[[2]]) # Genomes 1 and 3
unlist(DNA[[3]]) # Genomes 2 and 3 
```




















